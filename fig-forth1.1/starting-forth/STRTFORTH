( "Upgrades" APX Forth to "Starting Forth")

: NOT ( fl-fl) 0 = ;
: R@ ( -n) I ;
: 1- 1 - ;

: <> ( n n - fl) = 0 = ;
: 0<> ( n-fl) 0 = NOT ;
: 0> ( n-fl) DUP 0= SWAP 0< OR 0 = ;

: CREATE <BUILDS DOES> ;

CODE 2* 0 ,X ASL, 1 ,X ROL,
NEXT JMP,

CODE 2/ ( n-n) 1 ,X LSR,
0 ,X ROR, NEXT JMP,

53770 @ VARIABLE RND !
: RANDOM ( -n) RND @ 31421 *
  6972 + DUP RND ! ;

: MOVE ( addr1 addr2 u -)
  1- -1 SWAP DO SWAP DUP
  I + C@ ROT DUP >R I + C! R>
  -1 +LOOP 2DROP ;

( Does reverse of ROT)
: 1-2SWAP ROT ROT ;

: M+ ( d n — d-sum) S->D D+ ;

: SM/REM ( d1 n1 — n2 n3) M/ ;

( FM/MOD by NieDzejkob)
( https://forth-standard.org/standard/core/FMDivMOD)
(n2 - remainder, n3 - floored quotient)
: FM/MOD ( d1 n1 — n2 n3)
  DUP >R SM/REM
  ( if remainder is not zero &)
  ( has a different sign than divisor )
  OVER DUP 0<> SWAP 0< R@ 0< XOR
  AND IF 1- SWAP R> + SWAP ELSE
  R> DROP THEN ;

( Adapted from mult. & div.)
( algs. in "The Atari)
( Assembler" by Inman)
( Layout in N storage area:
(   Divisor (2 bytes) N0,N1
(   Multiplier (2 bytes) N2,N3
(   Multiplicand (4 bytes) N4-N7
( Push: multiplier [double] multiplicand [single] divisor [single]
( Result: Dividend
CODE M*/SUB ( d1 n2 n3 — d2)
( Copy 8 bytes from stack to N mem. area)
4 # LDA, SETUP JSR,
( Add 3 stack entries = 6 bytes)
0 # LDA, 3 # LDY,
BEGIN,
  DEX, DEX, 0 ,X STA, 1 ,X STA,
  DEY,
0= END,
( Multiply)
16 # LDY, BEGIN,
  4 ,X ASL, ( Shift dbl-prec. product)
  5 ,X ROL, ( left)
  2 ,X ROL, 3 ,X ROL,
  0 ,X ROL, ( Rotate-left hi-word)
  1 ,X ROL, ( of product.)
  N 2 + ASL,  ( Shift multiplier)
  N 3 + ROL, ( left - in N)
  IFCS,  ( If high-bit went to Carry)
    CLC,
    ( Add multiplicand in N to product)
    4 ,X LDA, N 6 + ADC, 4 ,X STA,
    5 ,X LDA, N 7 + ADC, 5 ,X STA,
    2 ,X LDA, N 4 + ADC, 2 ,X STA,
    3 ,X LDA, N 5 + ADC, 3 ,X STA,
    ( If addition causes dbl-prec.)
    ( product to carry)
    IFCS,
      ( Inc. hi-word of product)
      0 ,X INC,
    ENDIF,
  ENDIF,
  DEY, 0= END,
( Divide)
N 2 + STY,
32 # LDY, BEGIN,
  4 ,X ASL,
  5 ,X ROL, 2 ,X ROL, 3 ,X ROL,
  0 ,X ROL, 1 ,X ROL,
  1 ,X LDA, N 1 + CMP,
  IFEQ,
    0 ,X LDA, N CMP,
  ENDIF,
  IFCC,
    1 # LDA, N 2 + STA,
  ENDIF,
  N 2 + LDA,
  IFEQ,
    0 ,X LDA, SEC, N SBC, 0 ,X STA,
    1 ,X LDA, N 1 + SBC, 1 ,X STA,
    CLC, 4 ,X INC,
  ENDIF,
  DEY,
  0 # LDA, N 2 + STA,
  TYA,
0= END,
INX, INX, NEXT JMP,

( Unsigned equivalent of D.)
( Prints unsigned double-length)
( number, with space)
: UD. ( ud-) <# #S #> TYPE SPACE ;

: NEGATE ( n-'n) MINUS ;
: DNEGATE ( d-'d) DMINUS ;

: D= ( d1d2-fl) SWAP >R =
  R> ROT = AND ;
: D0= ( d1d2-fl) NOT SWAP NOT AND ;
: D- ( d1d2-d3) DNEGATE D+ ;
: DNEG? ( d1-fl) 0< SWAP DROP ;
: D< ( d1d2-fl) D- DNEG? ;

: M*/ ( d1 n1 n2 — d2) 0 SWAP
  DUP 0< IF ABS SWAP 1 XOR SWAP
  THEN >R SWAP
  DUP 0< IF ABS SWAP 1 XOR SWAP
  THEN >R 1-2SWAP
  DUP 0< IF DABS ROT 1 XOR
  1-2SWAP THEN
  R> R> M*/SUB
  ROT IF DNEGATE THEN ;

HEX
( UM* by Garth Wilson)
( http://forum.6502.org/viewtopic.php?f=9&t=689)
( u1 u2-ud)
CODE UM* 2 ,X LDA, N STA,
0 # LDA, 2 ,X STA,
3 ,X LDA, N 1+ STA,
0 # LDA, 3 ,X STA,
10 # LDY, BEGIN,
2 ,X ASL, 3 ,X ROL,
0 ,X ROL, 1 ,X ROL,
IFCS, CLC,
N LDA, 2 ,X ADC, 2 ,X STA,
N 1+ LDA, 3 ,X ADC, 3 ,X STA,
IFCS, 0 ,X INC,
IFEQ, 1 ,X INC, ENDIF,
ENDIF, ENDIF,
DEY,
0= END, NEXT JMP,
DECIMAL

( UM/MOD by Garth Wilson)
( http://6502.org/source/integers/ummodfix/ummodfix.htm)
( Signals overflow with result: -1 [quotient] -1 [remainder])
HEX
0 VARIABLE CARRY
(uq=unsigned quotiet, ur=unsigned remainder)
( ud1 u2-uq ur)
CODE UM/MOD SEC, 2 ,X LDA,
0 ,X SBC,
3 ,X LDA, 1 ,X SBC,
IFCS, INX, INX, FF # LDA,
0 ,X STA, 1 ,X STA,
2 ,X STA, 3 ,X STA, NEXT JMP,
ENDIF,
11 # LDY, BEGIN,
4 ,X ROL, 5 ,X ROL,
2 ,X ROL, 3 ,X ROL,
DEY, IFEQ, INX, INX, NEXT JMP,
ENDIF,
0 # LDA,
CARRY STA, CARRY ROL,
SEC, 2 ,X LDA, 0 ,X SBC, N STA,
3 ,X LDA, 1 ,X SBC, N 1+ STA,
CARRY LDA, 0 # SBC,
IFCS, N LDA, 2 ,X STA,
N 1+ LDA, 3 ,X STA,
ENDIF,
1 # LDA,
0= END, INX, INX, NEXT JMP,
DECIMAL

( Integer exponent)
: IEXP ( n n — n) DUP
  0 = IF 2DROP 1
  ELSE DUP
  1 = IF DROP
  ELSE SWAP DUP ROT
  1 DO OVER * LOOP
  SWAP DROP
  THEN THEN ;

( Following words used by >NUMBER)

( Counts # digits in n-len. str.)
( Leaves caddr. and cnt. on stack)
: DIGCOUNT ( addr n — addr n) 0.
  ROT SWAP DO
  SWAP DUP I + C@ BASE @ DIGIT
  IF DROP SWAP 1+
  ELSE SWAP LEAVE THEN
  LOOP ;

: >SVSTRLEN 1-2SWAP >R >R
  1-2SWAP R> R> ;
: >SVNUMLENEXP 2SWAP >R >R 2SWAP
  ROT R> R> ;
: >SVEXP 1-2SWAP >R >R SWAP R>
  R> ;
: >ADDACCUM 1-2SWAP >R >R M+ R>
  R> ;
: >DUPNUMLEN >R ROT DUP R> ;
  ( Bring up str. len.)
: >ROTSTRLEN >R >R ROT R> R> ;
: >END SWAP DROP >DUPNUMLEN +
  >ROTSTRLEN 1-2SWAP - ;

( ud1 c­addr1 u1 — ­­ud2 c­addr2 u2 )
: >NUMBER DUP >SVSTRLEN DIGCOUNT
  DUP DUP >SVNUMLENEXP
  0 DO DUP I + C@ BASE @ DIGIT
  DROP
  ROT 1- DUP >SVEXP BASE @ SWAP
  IEXP * >ADDACCUM
  LOOP >END ;

( Copies fourth value from return stack)
: J ( -n) R> R> R> R> DUP >R SWAP
  >R SWAP >R SWAP >R ;

( Decrements DO-loop idx)
: DO-1 COMPILE R> COMPILE 1-
  COMPILE >R ; IMMEDIATE

( Following words used by ACCEPT)

( "Add char")
: ACACH ( n-) >R ROT 1+ 1-2SWAP DUP
  EMIT
  SWAP 2DUP R> + C! SWAP DROP ;
( "Bk. sp.")
: ACBS ( -n) >R ROT 1- 1-2SWAP EMIT DUP
  R> 1- + 0 SWAP C! ;

( Ignores arrow keys, respects Bk. sp.)
: ACCEPT ( c-addr u1-u2)
  0 1-2SWAP 0 DO KEY
  DUP DUP
  28 < SWAP 31 > OR IF
  DUP 155 = IF DROP LEAVE
  ELSE DUP 126 <> IF I ACACH
  ELSE I 0> IF I ACBS R> 2 - >R
  ELSE DO-1 DROP
  THEN THEN THEN
  ELSE DO-1 DROP
  THEN
  LOOP DROP ;
