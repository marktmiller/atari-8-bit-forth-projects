( Math library ported from)
( Turbo Basic by Frank Ostrowski)
( Port by Mark Miller 9/1/2024)

CODE T_ZFR0 0 # LDA, FR0 STA,
FR0 1 + STA,
FR0 2 + STA, FR0 3 + STA,
FR0 4 + STA,
FR0 5 + STA, RTS,

CODE NORM_OV XSAVE LDX, RTS,
CODE NORM_OK CLC, ' NORM_OV JMP,
CODE NORM_SET0 ' T_ZFR0 JSR,
' NORM_OK JMP,

HEX
CODE NORM_MOK FR0 STY, TYA,
7F # AND,
71 # CMP, ( Chk overflow) IFCS,
' NORM_OV JMP, ENDIF,
F # CMP, ( Chk underflow) IFCS,
' NORM_OK JMP, ENDIF,
' T_ZFR0 JSR, ' NORM_OK JMP,
DECIMAL

( Move by 1)
CODE NORM_M1 FR0 1 + STA,
FR0 3 + LDA,
FR0 2 + STA, FR0 4 + LDA,
FR0 3 + STA,
FR0 5 + LDA, FR0 4 + STA,
FR0 5 + STX,
' NORM_MOK JMP,

( Move by 2)
CODE NORM_M2 FR0 1 + STA,
FR0 4 + LDA,
FR0 2 + STA, FR0 5 + LDA,
FR0 3 + STA,
FR0 4 + STX, 0 # LDA,
FR0 5 + STA,
IFEQ, ' NORM_MOK JMP, ENDIF,
' NORM_M1 JMP,

CODE NORM_M3 ( Move by 3)
FR0 1 + STA,
FR0 5 + LDA, FR0 2 + STA,
FR0 3 + STX,
0 # LDA, FR0 5 + STA,
FR0 4 + STA,
IFEQ, ' NORM_MOK JMP, ENDIF,
' NORM_M2 JMP,

( Move by 4)
CODE NORM_M4 FR0 1 + STA,
FR0 2 + STX,
0 # LDA, FR0 5 + STA,
FR0 4 + STA,
FR0 3 + STA, IFEQ,
' NORM_MOK JMP, ENDIF,
' NORM_M3 JMP,

( Set N to 0 if called directly)
CODE NORMALIZE XSAVE STX, N LDX,
FR0 LDY, CLD,
IFEQ, ' NORM_SET0 JMP, ENDIF,
FR0 1 + LDA,
IFNE, ' NORM_MOK JMP, ENDIF, DEY,
FR0 2 + LDA,
IFNE, ' NORM_M1 JMP, ENDIF, DEY,
FR0 3 + LDA,
IFNE, ' NORM_M2 JMP, ENDIF, DEY,
FR0 4 + LDA,
IFNE, ' NORM_M3 JMP, ENDIF, DEY,
FR0 5 + LDA,
IFNE, ' NORM_M4 JMP, ENDIF, DEY,
TXA,
IFEQ, ' NORM_SET0 JMP, ENDIF,
FR0 1 + STA,
IFNE, ' NORM_MOK JMP, ENDIF,
' NORM_M4 JMP,

CODE NORMDIVMUL FR0 6 + LDA,
N STA,
' NORMALIZE JMP,

HEX
D20A CONSTANT TRANDOM
CODE X_RND XSAVE STX, 3F # LDA,
FR0 STA, 5 # LDX,
BEGIN, BEGIN, TRANDOM LDA,
F0 # AND, A0 # CMP,
IFCS, 1 # LDY, ENDIF, IFCC,
0 # LDY, ENDIF,
0= END, FR1 STA, BEGIN,
TRANDOM LDA,
F # AND, A # CMP, IFCS, 1 # LDY,
ENDIF,
IFCC, 0 # LDY, ENDIF, 0= END,
FR1 ORA,
FR0 ,X STA, DEX, 0= UNTIL,
0 # LDA, N STA,
XSAVE LDX, ' NORMALIZE JMP,

CODE RNDSUB ' T_ZFR0 JSR,
' X_RND JSR, NEXT JMP,

: TRND RNDSUB F> ;

CODE FMOVE FR0 LDA, FR1 STA,
FR0 1+ LDA,
FR1 1 + STA, FR0 2 + LDA,
FR1 2 + STA,
FR0 3 + LDA, FR1 3 + STA,
FR0 4 + LDA,
FR1 4 + STA, FR0 5 + LDA,
FR1 5 + STA,
RTS,

0 VAR FPTMP0 6 ALLOT
0 VAR FPTMP1 6 ALLOT
0 VAR FPTMP2 6 ALLOT
0 VAR FPTMP3 6 ALLOT
0 VAR FPTMP4 6 ALLOT
0 VAR FPTMP5 6 ALLOT
CODE EXPAND_POW2 XSAVE STX,
SED, CLC,
( First part: FPTMP*+7=FR1)
( FPTMP*+6=FR1*2)
FR1 5 + LDA, FPTMP5 7 + STA,
FR1 5 + ADC,
FPTMP5 6 + STA,
FR1 4 + LDA, FPTMP4 7 + STA,
FR1 4 + ADC,
FPTMP4 6 + STA,
FR1 3 + LDA, FPTMP3 7 + STA,
FR1 3 + ADC,
FPTMP3 6 + STA,
FR1 2 + LDA, FPTMP2 7 + STA,
FR1 2 + ADC,
FPTMP2 6 + STA,
FR1 1 + LDA, FPTMP1 7 + STA,
FR1 1 + ADC,
FPTMP1 6 + STA,
( Second part: FPTMP*+5=FR1*4)
( FPTMP*+4=FR1*8)
0 # LDA, FPTMP0 7 + STA, 0 # ADC,
FPTMP0 6 + STA,
2 # LDX, BEGIN,
FPTMP5 4 + ,X LDA,
FPTMP5 4 + ,X ADC,
FPTMP5 3 + ,X STA,
FPTMP4 4 + ,X LDA,
FPTMP4 4 + ,X ADC,
FPTMP4 3 + ,X STA,
FPTMP3 4 + ,X LDA,
FPTMP3 4 + ,X ADC,
FPTMP3 3 + ,X STA,
FPTMP2 4 + ,X LDA,
FPTMP2 4 + ,X ADC,
FPTMP2 3 + ,X STA,
FPTMP1 4 + ,X LDA,
FPTMP1 4 + ,X ADC,
FPTMP1 3 + ,X STA,
FPTMP0 4 + ,X LDA,
FPTMP0 4 + ,X ADC,
FPTMP0 3 + ,X STA,
DEX, 0= END,
( Third part: FPTMP*+3=FR1*8+FR1*2=FR1*10)
FPTMP5 6 + LDA, FPTMP5 4 + ADC,
FPTMP5 3 + STA,
FPTMP4 6 + LDA, FPTMP4 4 + ADC,
FPTMP4 3 + STA,
FPTMP3 6 + LDA, FPTMP3 4 + ADC,
FPTMP3 3 + STA,
FPTMP2 6 + LDA, FPTMP2 4 + ADC,
FPTMP2 3 + STA,
FPTMP1 6 + LDA, FPTMP1 4 + ADC,
FPTMP1 3 + STA,
FPTMP0 6 + LDA, FPTMP0 4 + ADC,
FPTMP0 3 + STA,
( Fourth part: FPTMP*+2=FR1*20)
( FPTMP*+1=FR1*40 FPTMP*=FR1*80)
3 # LDX, BEGIN, DEX,
FPTMP5 1 + ,X LDA,
FPTMP5 1 + ,X ADC, FPTMP5 ,X STA,
FPTMP4 1 + ,X LDA,
FPTMP4 1 + ,X ADC, FPTMP4 ,X STA,
FPTMP3 1 + ,X LDA,
FPTMP3 1 + ,X ADC, FPTMP3 ,X STA,
FPTMP2 1 + ,X LDA,
FPTMP2 1 + ,X ADC, FPTMP2 ,X STA,
FPTMP1 1 + ,X LDA,
FPTMP1 1 + ,X ADC, FPTMP1 ,X STA,
FPTMP0 1 + ,X LDA,
FPTMP0 1 + ,X ADC, FPTMP0 ,X STA,
TXA, 0= UNTIL,
( Move FR0 to FR1)
FR0 1 + LDA, FR1 1 + STA,
FR0 2 + LDA, FR1 2 + STA,
FR0 3 + LDA, FR1 3 + STA,
FR0 4 + LDA, FR1 4 + STA,
FR0 5 + LDA, FR1 5 + STA,
( T_ZFR0 rout)
0 # LDA, FR0 STA, FR0 1+ STA,
FR0 2 + STA,
FR0 3 + STA, FR0 4 + STA,
FR0 5 + STA,
XSAVE LDX, RTS,

CODE FP_ZERO CLC, ' T_ZFR0 JMP,

CODE RET_CLC CLC, RTS,

CODE RET_SEC SEC, RTS,

CODE FMUL FR0 LDA,
IFEQ, ' RET_CLC JMP, ENDIF,
FR1 LDA,
IFEQ, ' FP_ZERO JMP, ENDIF,
FR0 EOR, 80 # AND,
EE STA, ( loc. for sign of FP number)
FR1 LDA, 7F # AND, FR1 STA,
FR0 LDA,
7F # AND, SEC, 40 # SBC, SEC,
FR1 ADC,
IFMI, ' RET_SEC JMP, ENDIF,
EE ORA, N STA,
N LDY, ' EXPAND_POW2 JSR,
FR0 6 + STA,
FR0 7 + STA, FR0 8 + STA,
FR0 9 + STA,
FR0 A + STA, FR0 B + STA,
FR0 STY,
( 5-offset of MUL_PAIR)
8 # LDY, BEGIN, 1 # LDA, N STA,
DEY, FR1 5 + LSR,
IFCS, 0 # LDA, N STA, CLC,
FR0 5 + 5 + LDA, FPTMP5 ,Y ADC,
FR0 5 + 5 + STA,
FR0 4 + 5 + LDA, FPTMP4 ,Y ADC,
FR0 4 + 5 + STA,
FR0 3 + 5 + LDA, FPTMP3 ,Y ADC,
FR0 3 + 5 + STA,
FR0 2 + 5 + LDA, FPTMP2 ,Y ADC,
FR0 2 + 5 + STA,
FR0 1 + 5 + LDA, FPTMP1 ,Y ADC,
FR0 1 + 5 + STA,
FR0 5 + LDA, FPTMP0 ,Y ADC,
FR0 5 + STA,
ENDIF,
N LDA, IFNE, FR1 5 + LDA, IFEQ,
0 # LDY, ENDIF, ENDIF,
IFEQ, TYA, ENDIF,
0= UNTIL,
( 4-offset of MUL_PAIR)
8 # LDY, BEGIN, 1 # LDA, N STA,
DEY, FR1 4 + LSR,
IFCS, 0 # LDA, N STA, CLC,
FR0 5 + 4 + LDA, FPTMP5 ,Y ADC,
FR0 5 + 4 + STA,
FR0 4 + 4 + LDA, FPTMP4 ,Y ADC,
FR0 4 + 4 + STA,
FR0 3 + 4 + LDA, FPTMP3 ,Y ADC,
FR0 3 + 4 + STA,
FR0 2 + 4 + LDA, FPTMP2 ,Y ADC,
FR0 2 + 4 + STA,
FR0 1 + 4 + LDA, FPTMP1 ,Y ADC,
FR0 1 + 4 + STA,
FR0 4 + LDA, FPTMP0 ,Y ADC,
FR0 4 + STA,
ENDIF,
N LDA, IFNE, FR1 4 + LDA, IFEQ,
0 # LDY, ENDIF, ENDIF,
IFEQ, TYA, ENDIF,
0= UNTIL,
( 3-offset of MUL_PAIR)
8 # LDY, BEGIN, 1 # LDA, N STA,
DEY, FR1 3 + LSR,
IFCS, 0 # LDA, N STA, CLC,
FR0 5 + 3 + LDA, FPTMP5 ,Y ADC,
FR0 5 + 3 + STA,
FR0 4 + 3 + LDA, FPTMP4 ,Y ADC,
FR0 4 + 3 + STA,
FR0 3 + 3 + LDA, FPTMP3 ,Y ADC,
FR0 3 + 3 + STA,
FR0 2 + 3 + LDA, FPTMP2 ,Y ADC,
FR0 2 + 3 + STA,
FR0 1 + 3 + LDA, FPTMP1 ,Y ADC,
FR0 1 + 3 + STA,
FR0 3 + LDA, FPTMP0 ,Y ADC,
FR0 3 + STA,
ENDIF,
N LDA, IFNE, FR1 3 + LDA, IFEQ,
0 # LDY, ENDIF, ENDIF,
IFEQ, TYA, ENDIF,
0= UNTIL,
( 2-offset of MUL_PAIR)
8 # LDY, BEGIN, 1 # LDA, N STA,
DEY, FR1 2 + LSR,
IFCS, 0 # LDA, N STA, CLC,
FR0 5 + 2 + LDA, FPTMP5 ,Y ADC,
FR0 5 + 2 + STA,
FR0 4 + 2 + LDA, FPTMP4 ,Y ADC,
FR0 4 + 2 + STA,
FR0 3 + 2 + LDA, FPTMP3 ,Y ADC,
FR0 3 + 2 + STA,
FR0 2 + 2 + LDA, FPTMP2 ,Y ADC,
FR0 2 + 2 + STA,
FR0 1 + 2 + LDA, FPTMP1 ,Y ADC,
FR0 1 + 2 + STA,
FR0 2 + LDA, FPTMP0 ,Y ADC,
FR0 2 + STA,
ENDIF,
N LDA, IFNE, FR1 2 + LDA, IFEQ,
0 # LDY, ENDIF, ENDIF,
IFEQ, TYA, ENDIF,
0= UNTIL,
( 1-offset of MUL_PAIR)
8 # LDY, BEGIN, 1 # LDA, N STA,
DEY, FR1 1 + LSR,
IFCS, 0 # LDA, N STA, CLC,
FR0 5 + 1 + LDA, FPTMP5 ,Y ADC,
FR0 5 + 1 + STA,
FR0 4 + 1 + LDA, FPTMP4 ,Y ADC,
FR0 4 + 1 + STA,
FR0 3 + 1 + LDA, FPTMP3 ,Y ADC,
FR0 3 + 1 + STA,
FR0 2 + 1 + LDA, FPTMP2 ,Y ADC,
FR0 2 + 1 + STA,
FR0 1 + 1 + LDA, FPTMP1 ,Y ADC,
FR0 1 + 1 + STA,
FR0 1 + LDA, FPTMP0 ,Y ADC,
FR0 1 + STA,
ENDIF,
N LDA, IFNE, FR1 1 + LDA, IFEQ,
0 # LDY, ENDIF, ENDIF,
IFEQ, TYA, ENDIF,
0= UNTIL,
' NORMDIVMUL JMP,

CODE FSQ ' FMOVE JSR, ' FMUL JMP,

CODE FMULSUB ' FMUL JSR,
NEXT JMP,

: F* <F FMULSUB F> ;

CODE FMOVESUB ' FMOVE JSR, NEXT JMP,

CODE L27FC CLC, RTS,

CODE L27FE SEC, RTS,

CODE FDIVEND ' NORMDIVMUL JMP,

CODE FDIVSKP0
( Skip if remainder is 0 at end of FDIV)
BEGIN, FR0 1 + ,X ROL, INY,
8 # CPY, 0= END,
XSAVE LDX, ' FDIVEND JMP,

CODE FDIV FR1 LDA, IFEQ,
' L27FE JMP, ENDIF,
FR0 LDA, IFEQ, ' L27FC JMP,
ENDIF, FR1 EOR
80 # AND, EE STA, FR1 LDA,
7F # AND, FR1 STA,
FR0 LDA, 7F # AND, SEC, FR1 SBC,
CLC, 40 # ADC,
IFMI, ' L27FE JMP, ENDIF, EE ORA,
N STA, N LDY,
' EXPAND_POW2 JSR,
FR1 6 + STA, FR1 7 + STA,
FR1 8 + STA,
FR1 9 + STA, FR1 A + STA,
FR1 STA,
FR0 6 + STA, FR0 STY,
( 0-offset for DIV_PAIR)
0 # LDY, BEGIN, FR1 LDA,
FPTMP0 ,Y CMP,
IFEQ, FR1 1 + LDA, FPTMP1 ,Y CMP,
IFEQ, FR1 2 + LDA,
FPTMP2 ,Y CMP, IFEQ, FR1 3 + LDA,
FPTMP3 ,Y CMP,
IFEQ, FR1 4 + LDA, FPTMP4 ,Y CMP,
IFEQ, FR1 5 + LDA,
FPTMP5 ,Y CMP, IFEQ, XSAVE STX,
0 # LDX,
( X register is restored in FDIVSKP0)
' FDIVSKP0 JMP, ENDIF,
ENDIF, ENDIF, ENDIF, ENDIF,
ENDIF,
IFCS, FR1 5 + LDA, FPTMP5 ,Y SBC,
FR1 5 + STA,
FR1 4 + LDA, FPTMP4 ,Y SBC,
FR1 4 + STA,
FR1 3 + LDA, FPTMP3 ,Y SBC,
FR1 3 + STA,
FR1 2 + LDA, FPTMP2 ,Y SBC,
FR1 2 + STA,
FR1 1 + LDA, FPTMP1 ,Y SBC,
FR1 1 + STA,
FR1 LDA, FPTMP0 ,Y SBC, FR1 STA,
ENDIF,
FR0 1 + ROL, INY, 8 # CPY,
0= END,
( 1-offset for DIV_PAIR)
0 # LDY, BEGIN, FR1 1 + LDA,
FPTMP0 ,Y CMP,
IFEQ, FR1 1 + 1 + LDA,
FPTMP1 ,Y CMP,
IFEQ, FR1 2 + 1 + LDA,
FPTMP2 ,Y CMP,
IFEQ, FR1 3 + 1 + LDA,
FPTMP3 ,Y CMP,
IFEQ, FR1 4 + 1 + LDA,
FPTMP4 ,Y CMP,
IFEQ, FR1 5 + 1 + LDA,
FPTMP5 ,Y CMP,
IFEQ, XSAVE STX, 1 # LDX,
( X register is restored in FDIVSKP0)
' FDIVSKP0 JMP,
ENDIF, ENDIF, ENDIF, ENDIF,
ENDIF, ENDIF,
IFCS,
FR1 5 + 1 + LDA, FPTMP5 ,Y SBC,
FR1 5 + 1 + STA,
FR1 4 + 1 + LDA, FPTMP4 ,Y SBC,
FR1 4 + 1 + STA,
FR1 3 + 1 + LDA, FPTMP3 ,Y SBC,
FR1 3 + 1 + STA,
FR1 2 + 1 + LDA, FPTMP2 ,Y SBC,
FR1 2 + 1 + STA,
FR1 1 + 1 + LDA, FPTMP1 ,Y SBC,
FR1 1 + 1 + STA,
FR1 1 + LDA, FPTMP0 ,Y SBC,
FR1 1 + STA,
ENDIF,
FR0 1 + 1 + ROL, INY, 8 # CPY,
0= END,
( 2-offset for DIV_PAIR)
0 # LDY, BEGIN, FR1 2 + LDA,
FPTMP0 ,Y CMP,
IFEQ, FR1 1 + 2 + LDA,
FPTMP1 ,Y CMP,
IFEQ, FR1 2 + 2 + LDA,
FPTMP2 ,Y CMP,
IFEQ, FR1 3 + 2 + LDA,
FPTMP3 ,Y CMP,
IFEQ, FR1 4 + 2 + LDA,
FPTMP4 ,Y CMP,
IFEQ, FR1 5 + 2 + LDA,
FPTMP5 ,Y CMP,
IFEQ, XSAVE STX, 2 # LDX,
( X register is restored in FDIVSKP0)
' FDIVSKP0 JMP,
ENDIF, ENDIF, ENDIF, ENDIF,
ENDIF, ENDIF,
IFCS,
FR1 5 + 2 + LDA, FPTMP5 ,Y SBC,
FR1 5 + 2 + STA,
FR1 4 + 2 + LDA, FPTMP4 ,Y SBC,
FR1 4 + 2 + STA,
FR1 3 + 2 + LDA, FPTMP3 ,Y SBC,
FR1 3 + 2 + STA,
FR1 2 + 2 + LDA, FPTMP2 ,Y SBC,
FR1 2 + 2 + STA,
FR1 1 + 2 + LDA, FPTMP1 ,Y SBC,
FR1 1 + 2 + STA,
FR1 2 + LDA, FPTMP0 ,Y SBC,
FR1 2 + STA,
ENDIF,
FR0 1 + 2 + ROL, INY, 8 # CPY,
0= END,
( 3-offset for DIV_PAIR)
0 # LDY, BEGIN, FR1 3 + LDA,
FPTMP0 ,Y CMP,
IFEQ, FR1 1 + 3 + LDA,
FPTMP1 ,Y CMP,
IFEQ, FR1 2 + 3 + LDA,
FPTMP2 ,Y CMP,
IFEQ, FR1 3 + 3 + LDA,
FPTMP3 ,Y CMP,
IFEQ, FR1 4 + 3 + LDA,
FPTMP4 ,Y CMP,
IFEQ, FR1 5 + 3 + LDA,
FPTMP5 ,Y CMP,
IFEQ, XSAVE STX, 3 # LDX,
( X register is restored in FDIVSKP0)
' FDIVSKP0 JMP,
ENDIF, ENDIF, ENDIF, ENDIF,
ENDIF, ENDIF,
IFCS,
FR1 5 + 3 + LDA, FPTMP5 ,Y SBC,
FR1 5 + 3 + STA,
FR1 4 + 3 + LDA, FPTMP4 ,Y SBC,
FR1 4 + 3 + STA,
FR1 3 + 3 + LDA, FPTMP3 ,Y SBC,
FR1 3 + 3 + STA,
FR1 2 + 3 + LDA, FPTMP2 ,Y SBC,
FR1 2 + 3 + STA,
FR1 1 + 3 + LDA, FPTMP1 ,Y SBC,
FR1 1 + 3 + STA,
FR1 3 + LDA, FPTMP0 ,Y SBC,
FR1 3 + STA,
ENDIF,
FR0 1 + 3 + ROL, INY, 8 # CPY,
0= END,
( 4-offset for DIV_PAIR)
0 # LDY, BEGIN, FR1 4 + LDA,
FPTMP0 ,Y CMP,
IFEQ, FR1 1 + 4 + LDA,
FPTMP1 ,Y CMP,
IFEQ, FR1 2 + 4 + LDA,
FPTMP2 ,Y CMP,
IFEQ, FR1 3 + 4 + LDA,
FPTMP3 ,Y CMP,
IFEQ, FR1 4 + 4 + LDA,
FPTMP4 ,Y CMP,
IFEQ, FR1 5 + 4 + LDA,
FPTMP5 ,Y CMP,
IFEQ, XSAVE STX, 4 # LDX,
( X register is restored in FDIVSKP0)
' FDIVSKP0 JMP,
ENDIF, ENDIF, ENDIF, ENDIF,
ENDIF, ENDIF,
IFCS,
FR1 5 + 4 + LDA, FPTMP5 ,Y SBC,
FR1 5 + 4 + STA,
FR1 4 + 4 + LDA, FPTMP4 ,Y SBC,
FR1 4 + 4 + STA,
FR1 3 + 4 + LDA, FPTMP3 ,Y SBC,
FR1 3 + 4 + STA,
FR1 2 + 4 + LDA, FPTMP2 ,Y SBC,
FR1 2 + 4 + STA,
FR1 1 + 4 + LDA, FPTMP1 ,Y SBC,
FR1 1 + 4 + STA,
FR1 4 + LDA, FPTMP0 ,Y SBC,
FR1 4 + STA,
ENDIF,
FR0 1 + 4 + ROL, INY, 8 # CPY,
0= END,
FR0 1 + LDA,
IFNE, ' FDIVEND JMP, ENDIF,
( 5-offset for DIV_PAIR)
0 # LDY, BEGIN, FR1 5 + LDA,
FPTMP0 ,Y CMP,
IFEQ, FR1 1 + 5 + LDA,
FPTMP1 ,Y CMP,
IFEQ, FR1 2 + 5 + LDA,
FPTMP2 ,Y CMP,
IFEQ, FR1 3 + 5 + LDA,
FPTMP3 ,Y CMP,
IFEQ, FR1 4 + 5 + LDA,
FPTMP4 ,Y CMP,
IFEQ, FR1 5 + 5 + LDA,
FPTMP5 ,Y CMP,
IFEQ, XSAVE STX, 5 # LDX,
( X register is restored in FDIVSKP0)
' FDIVSKP0 JMP,
ENDIF, ENDIF, ENDIF, ENDIF,
ENDIF, ENDIF,
IFCS,
FR1 5 + 5 + LDA, FPTMP5 ,Y SBC,
FR1 5 + 5 + STA,
FR1 4 + 5 + LDA, FPTMP4 ,Y SBC,
FR1 4 + 5 + STA,
FR1 3 + 5 + LDA, FPTMP3 ,Y SBC,
FR1 3 + 5 + STA,
FR1 2 + 5 + LDA, FPTMP2 ,Y SBC,
FR1 2 + 5 + STA,
FR1 1 + 5 + LDA, FPTMP1 ,Y SBC,
FR1 1 + 5 + STA,
FR1 5 + LDA, FPTMP0 ,Y SBC,
FR1 5 + STA,
ENDIF,
FR0 1 + 5 + ROL, INY, 8 # CPY,
0= END,
' FDIVEND JMP,

CODE FDIVSUB ' FDIV JSR,
NEXT JMP,
DECIMAL

: F/ <F FDIVSUB F> ;

CODE X_2FDROP INX, INX, INX, INX,
INX, INX, INX,
INX, INX, INX, INX, INX, RTS,

CODE X_TRUE 1 # LDA, PUSH0A JMP,

CODE X_FALSE 0 # LDA, PUSH0A JMP,

CODE FENDT ' X_2FDROP JSR,
CLD, ' X_TRUE JMP,

CODE FENDF ' X_2FDROP JSR,
CLD, ' X_FALSE JMP,

HEX
F7 CONST ZTEMP4

CODE RET_CLC2 RTS,

CODE DO_SUB SEC,
FR0 5 + LDA, FR1 5 + SBC,
FR0 5 + STA,
FR0 4 + LDA, FR1 4 + SBC,
FR0 4 + STA,
FR0 3 + LDA, FR1 3 + SBC,
FR0 3 + STA,
FR0 2 + LDA, FR1 2 + SBC,
FR0 2 + STA,
FR0 1 + LDA, FR1 1 + SBC,
FR0 1 + STA,
IFCS, 0 # LDA, N STA,
' NORMALIZE JMP,
ENDIF,
( SUB was negative, negate number)
FR0 LDA, 80 # EOR, FR0 STA, SEC,
TYA, FR0 5 + SBC, FR0 5 + STA,
TYA, FR0 4 + SBC, FR0 4 + STA,
TYA, FR0 3 + SBC, FR0 3 + STA,
TYA, FR0 2 + SBC, FR0 2 + STA,
TYA, FR0 1 + SBC, FR0 1 + STA,
0 # LDA, N STA, ' NORMALIZE JMP,

CODE FADD_OK
( Check if we need ADD or SUB)
SED, FR0 LDA, FR1 EOR, IFMI,
' DO_SUB JMP, ENDIF,
CLC, FR0 5 + LDA, FR1 5 + ADC,
FR0 5 + STA,
FR0 4 + LDA, FR1 4 + ADC,
FR0 4 + STA,
FR0 3 + LDA, FR1 3 + ADC,
FR0 3 + STA,
FR0 2 + LDA, FR1 2 + ADC,
FR0 2 + STA,
FR0 1 + LDA, FR1 1 + ADC,
FR0 1 + STA,
IFCS, FR0 4 + LDA, FR0 5 + STA,
FR0 3 + LDA, FR0 4 + STA,
FR0 2 + LDA, FR0 3 + STA,
FR0 1 + LDA, FR0 2 + STA,
1 # LDA, FR0 1 + STA, FR0 INC,
ENDIF,
0 # LDA, N STA, ' NORMALIZE JMP,

CODE FADD FR1 LDA, 7F # AND,
IFEQ, ' RET_CLC2 JMP, ENDIF,
ZTEMP4 STA,
FR0 LDA, 7F # AND, SEC,
ZTEMP4 SBC,
IFCC,
( If negative result, swap operands and retry)
FR0 LDA, FR1 LDY, FR1 STA,
FR0 STY,
FR0 1 + LDA, FR1 1 + LDY,
FR1 1 + STA, FR0 1 + STY,
FR0 2 + LDA, FR1 2 + LDY,
FR1 2 + STA, FR0 2 + STY,
FR0 3 + LDA, FR1 3 + LDY,
FR1 3 + STA, FR0 3 + STY,
FR0 4 + LDA, FR1 4 + LDY,
FR1 4 + STA, FR0 4 + STY,
FR0 5 + LDA, FR1 5 + LDY,
FR1 5 + STA, FR0 5 + STY,
' FADD JMP,
ENDIF,
N STA, N LDY, IFNE,
( Exponents differ, move right smaller operand)
( before adding)
DEY, IFNE, ( Not move by 1)
DEY, IFNE, ( Not move by 2)
DEY, IFNE, ( Not move by 3)
DEY, IFNE, ' RET_CLC2 JMP, ENDIF,
( Move by 4)
FR1 1 + LDA, FR1 5 + STA,
FR1 4 + STY,
FR1 3 + STY, FR1 2 + STY,
FR1 1 + STY, ' FADD_OK JMP,
ENDIF,
( Move by 3)
FR1 2 + LDA, FR1 5 + STA,
FR1 1 + LDA, FR1 4 + STA,
FR1 3 + STY, FR1 2 + STY,
FR1 1 + STY, ' FADD_OK JMP,
ENDIF,
( Move by 2)
FR1 3 + LDA, FR1 5 + STA,
FR1 2 + LDA, FR1 4 + STA,
FR1 1 + LDA, FR1 3 + STA,
FR1 2 + STY,
FR1 1 + STY, ' FADD_OK JMP,
ENDIF,
( Move by 1)
FR1 4 + LDA, FR1 5 + STA,
FR1 3 + LDA, FR1 4 + STA,
FR1 2 + LDA, FR1 3 + STA,
FR1 1 + LDA, FR1 2 + STA,
FR1 1 + STY,
ENDIF, ' FADD_OK JMP,

CODE FSUB FR1 LDA, 80 # EOR,
FR1 STA,
' FADD JMP,

CODE FADDSUB ' FADD JSR, NEXT JMP,
CODE FSUBSUB ' FSUB JSR, NEXT JMP,

: F+ <F FADDSUB F> ;
: F- <F FSUBSUB F> ;

5E0 CONST PLYARG

CODE FMOVPLYARG
( Move FR0 to PLYARG)
FR0 LDA, PLYARG STA, FR0 1 + LDA,
PLYARG 1 + STA,
FR0 2 + LDA, PLYARG 2 + STA,
FR0 3 + LDA, PLYARG 3 + STA,
FR0 4 + LDA, PLYARG 4 + STA,
FR0 5 + LDA, PLYARG 5 + STA,
RTS,

CODE FLD1P 5 # LDY, FLPTR )Y LDA,
FR1 5 + STA,
DEY, FLPTR )Y LDA, FR1 4 + STA,
DEY, FLPTR )Y LDA, FR1 3 + STA,
DEY, FLPTR )Y LDA, FR1 2 + STA,
DEY, FLPTR )Y LDA, FR1 1 + STA,
DEY, FLPTR )Y LDA, FR1 STA,
RTS,

CODE PLY_END RTS,

CODE PLYEVL FLPTR STX,
FLPTR 1 + STY,
XSAVE LDX, EF STA,
' FMOVPLYARG JSR,
' FLD1P JSR, EF DEC,
BEGIN, ' FMUL JSR,
IFCS, ' PLY_END JMP, ENDIF,
FLPTR LDA, 6 # ADC, FLPTR STA,
IFCS, FLPTR 1 + INC, ENDIF,
' FLD1P JSR, ' FADD JSR,
IFCS, ' PLY_END JMP, ENDIF,
EF DEC,
IFEQ, ' PLY_END JMP, ENDIF,
PLYARG LDA, FR1 STA,
PLYARG 1 + LDA, FR1 1 + STA,
PLYARG 2 + LDA, FR1 2 + STA,
PLYARG 3 + LDA, FR1 3 + STA,
PLYARG 4 + LDA, FR1 4 + STA,
PLYARG 5 + LDA, FR1 5 + STA,
( Keeps looping until jump out)
1 # LDA, 0= END,

CODE FLD1 40 # LDA, FR0 STA,
1 # LDY, FR0 1 + STY,
DEY, FR0 2 + STY, FR0 3 + STY,
FR0 4 + STY,
FR0 5 + STY, RTS,

CODE L32D2 0 # LDA, FR0 5 + ASL,
FR0 4 + ROL, FR0 3 + ROL,
FR0 2 + ROL,
FR0 1 + ROL, ROL.A,
FR0 5 + ASL, FR0 4 + ROL,
FR0 3 + ROL,
FR0 2 + ROL, FR0 1 + ROL, ROL.A,
FR0 5 + ASL, FR0 4 + ROL,
FR0 3 + ROL,
FR0 2 + ROL, FR0 1 + ROL, ROL.A,
FR0 5 + ASL, FR0 4 + ROL,
FR0 3 + ROL,
FR0 2 + ROL, FR0 1 + ROL, ROL.A,
RTS,

CODE FDIV10
FR0 1 + LDA, 10 # CMP, IFCS,
LSR.A,
FR0 2 + ROR, FR0 3 + ROR,
FR0 4 + ROR, FR0 5 + ROR,
LSR.A,
FR0 2 + ROR, FR0 3 + ROR,
FR0 4 + ROR, FR0 5 + ROR,
LSR.A,
FR0 2 + ROR, FR0 3 + ROR,
FR0 4 + ROR, FR0 5 + ROR,
LSR.A,
FR0 2 + ROR, FR0 3 + ROR,
FR0 4 + ROR, FR0 5 + ROR,
FR0 1 + STA,
RTS, ENDIF,
( Divide by 100, then multiply by 10)
FR0 DEC, ' L32D2 JMP,

CODE FMUL10 FR0 1 + LDA,
10 # CMP,
IFCC, ' L32D2 JMP, ENDIF,
( Multiply by 100, then divide by 10)
FR0 INC, ' FDIV10 JMP,

DE89 CONST LOG10E
DE CONST P10COFHB
4D CONST P10COFLB

CODE L2F43 RTS,
CODE L2FB9 SEC, RTS,

CODE EXP10
( Calculate FR0=EXP10[FR0])
0 # LDA, F1 STA, FR0 LDA,
F0 STA,
7F # AND, FR0 STA, 40 # CMP,
IFCS,
IFNE, ' L2F43 JMP, ENDIF,
FR0 1 + LDA, F0 # AND, LSR.A,
F1 STA,
LSR.A, LSR.A, F1 ADC, F1 STA,
FR0 1 + LDA, F # AND, F1 ADC,
F1 STA,
0 # LDA, FR0 1 + STA, N STA,
' NORMALIZE JSR,
ENDIF,
XSAVE STX, A # LDA,
P10COFLB # LDX, P10COFHB # LDY,
( X reg. is restored in PLYEVL)
' PLYEVL JSR, ' FSQ JSR, F1 LDA,
IFNE,
LSR.A, CLC, FR0 ADC,
IFMI, ' L2FB9 JMP, ENDIF,
FR0 STA, F1 LSR,
IFCS, ' FMUL10 JSR, ENDIF,
ENDIF,
F0 ASL,
IFCS, ' FMOVE JSR, ' FLD1 JSR,
' FDIV JMP, ENDIF,
RTS,

CODE FEXPROUT
( Calculate FR0 = EXP[FR0])
XSAVE STX, 6 # LDX, BEGIN,
DEX, LOG10E ,X LDA, FR1 ,X STA,
TXA,
0= END, XSAVE LDX,
' FMUL JSR, IFCS, ' L2F43 JMP,
ENDIF,
' EXP10 JMP,

CODE FEXPSUB ' FEXPROUT JSR,
NEXT JMP,

: FEXP FS FEXPSUB F> ;

CODE RETVAL RTS,

CODE ADD1 C0 # LDA, FR1 STA,
1 # LDY,
FR1 1 + STY, DEY, FR1 2 + STY,
FR1 3 + STY,
FR1 4 + STY, FR1 5 + STY,
' FADD JSR, RTS,

CODE X_INT FR0 LDA, 7F # AND, SEC,
40 # SBC,
IFCS, XSAVE STX, N STA, N LDX,
4 # CPX,
IFCS, XSAVE LDX, RTS, ENDIF,
0 # LDA, N STA, N LDY,
BEGIN, FR0 2 + ,X ORA,
FR0 2 + ,X STY,
INX, 4 # CPX,
0= END, XSAVE LDX, FR0 BIT,
IFPL, ' RETVAL JMP, ENDIF,
N STA, N LDY,
IFEQ, ' RETVAL JMP, ENDIF,
' ADD1 JMP,
ENDIF, FR0 ASL, ' T_ZFR0 JSR,
IFCC, ' RETVAL JMP, ENDIF,
IFCS, ' ADD1 JMP, ENDIF,

CODE INTSUB ' X_INT JSR,
NEXT JMP, 

CREATE X10000L 0 LB C,
10000 LB C,
20000 LB C, 30000 LB C,
40000 LB C,
50000 LB C, 60000 LB C,

CREATE X10000H 0 HB C, 10000 HB C,
20000 HB C,
30000 HB C, 40000 HB C,
50000 HB C,
60000 HB C,

CREATE X1000 1000 , 2000 ,
3000 ,
4000 , 5000 , 6000 , 7000 ,
8000 ,
9000 ,

CREATE X100L 0 LB C, 100 LB C,
200 LB C, 300 LB C,
400 LB C, 500 LB C, 600 LB C,
700 LB C, 800 LB C,
900 LB C,

CREATE X100H 0 HB C, 100 HB C,
200 HB C, 300 HB C,
400 HB C, 500 HB C, 600 HB C,
700 HB C, 800 HB C,
900 HB C,

CODE L3301 FF # CMP,
IFCS, 50 # CPY, ENDIF, TXA,
0 # ADC, FR0 STA,
RTS,

CODE L330D TYA, F0 # AND, LSR.A,
FR0 STA, LSR.A,
LSR.A, FR0 ADC, FR0 STA, TYA,
F # AND,
FR0 2 + LDX, 50 # CPX, FR0 ADC,
FR0 STA, RTS,

CODE L337C RTS,

CODE L3353 TYA, F # AND, N STA,
N LDX,
X100L ,X LDA, FR0 ADC, FR0 STA,
X100H ,X LDA,
FR0 1 + ADC, FR0 1 + STA, TYA,
F0 # AND,
IFNE,
LSR.A, LSR.A, LSR.A, N STA,
N LDX,
FR0 LDA, X1000 2 - ,X ADC,
FR0 STA,
FR0 1 + LDA, X1000 1 - ,X ADC,
FR0 1 + STA,
ENDIF, RTS,

CODE L337D 7 # CPY,
IFCS, ' L337C JMP, ENDIF,
FR0 3 + LDA, F0 # AND, LSR.A,
FR0 STA, LSR.A,
LSR.A, FR0 ADC, FR0 STA,
FR0 3 + LDA, F # AND,
FR0 4 + LDX,
50 # CPX, FR0 ADC, FR0 STA,
X10000L ,Y LDA, FR0 ADC, FR0 STA,
X10000H ,Y LDA, FR0 1 + ADC,
FR0 1 + STA,
FR0 2 + LDY,
IFNE, ' L3353 JMP, ENDIF, RTS,

CODE FPI 0 # LDX,
FR0 1 + LDY, FR0 LDA,
FR0 1 + STX, SEC, 40 # SBC,
IFCC, ' L3301 JMP, ENDIF,
IFEQ ' L330D JMP, ENDIF,
2 # CMP,
IFEQ, ' L337D JMP, ENDIF,
IFCS, ' L337C JMP, ENDIF,
FR0 2 + LDA, F0 # AND, LSR.A,
FR0 STA,
LSR.A, LSR.A, FR0 ADC, FR0 STA,
FR0 2 + LDA, F # AND,
FR0 3 + LDX,
50 # CPX, FR0 ADC, FR0 STA,
' L3353 JMP,

CODE FPISUB XSAVE STX, ' FPI JSR,
XSAVE LDX, NEXT JMP,
DECIMAL

0 VAR INTSGN
: INT ( fl-n) FS INTSUB F> FGETEXP
  DROP INTSGN !
  DROP FABS FS FPISUB FR0 @
  INTSGN @ IF -1 * THEN ;

CODE F= SED, 4 ,X LDA,
IFEQ, 10 ,X LDA,
IFEQ, ' FENDT JMP, ENDIF,
' FENDF JMP,
ENDIF,
10 ,X CMP, IFEQ,
5 ,X LDA, 11 ,X CMP, IFEQ,
3 ,X LDA, 9 ,X CMP, IFEQ,
2 ,X LDA, 8 ,X CMP, IFEQ,
1 ,X LDA, 7 ,X CMP, IFEQ,
0 ,X LDA, 6 ,X CMP, IFEQ,
' FENDT JMP,
ENDIF, ENDIF, ENDIF, ENDIF,
ENDIF, ENDIF,
' FENDF JMP,

: F<> F= NOT ;

HEX
CODE IFP2 ZTEMP4 LSR,
( ADD_BIT $00255)
IFCS, 55 # ADC, INY, INY,
IFCS, INY, ENDIF,
ENDIF,
ZTEMP4 LSR, ( ADD_BIT $00511)
IFCS, 11 # ADC, N STA, N LDX,
TYA, 5 # ADC,
N STA, N LDY, TXA,
ENDIF,
ZTEMP4 LSR, ( ADD_BIT $01023)
IFCS, 23 # ADC, N STA, N LDX,
TYA, 10 # ADC,
N STA, N LDY, TXA,
ENDIF,
ZTEMP4 LSR, ( ADD_BIT $02047)
IFCS, 47 # ADC, N STA, N LDX,
TYA, 20 # ADC,
N STA, N LDY, TXA,
ENDIF,
ZTEMP4 LSR, ( ADD_BIT $04095)
IFCS, 95 # ADC, N STA, N LDX,
TYA, 40 # ADC,
N STA, N LDY, TXA,
ENDIF,
ZTEMP4 LSR, ( ADD_BIT $08191)
IFCS, 91 # ADC, N STA, N LDX,
TYA, 81 # ADC,
N STA, N LDY, TXA,
IFCS, FR0 1 + INC, ENDIF,
ENDIF,
ZTEMP4 LSR, ( ADD_BIT $16383)
IFCS, 83 # ADC, N STA, N LDX,
TYA, 63 # ADC,
N STA, N LDY, FR0 1 + LDA,
1 # ADC,
FR0 1 + STA, TXA,
ENDIF,
ZTEMP4 LSR, ( ADD_BIT $32767)
IFCS, 67 # ADC, N STA, N LDX,
TYA, 27 # ADC,
N STA, N LDY, FR0 1 + LDA,
3 # ADC,
FR0 1 + STA, TXA,
ENDIF,
XSAVE LDX, FR0 2 + STY,
FR0 3 + STA,
42 # LDA, FR0 STA, 0 # LDA,
N STA,
' NORMALIZE JMP,

CODE IFP FR0 LDY, FR0 1 + LDA,
ZTEMP4 STA,
' T_ZFR0 JSR, SED, TYA,
( If first byte is 0, skip)
IFNE, ( First get the lowest 3 bits directly)
LSR.A, LSR.A, LSR.A, LSR.A,
ZTEMP4 1 + STA,
TYA, 7 # AND, 0 # LDY,
( Test each remaining bit and add the BCD equivalent)
( if set)
( ADD_BIT $00007)
IFCS, 7 # ADC, ENDIF,
ZTEMP4 1 + LSR,
( ADD_BIT $00015)
IFCS, 15 # ADC, ENDIF,
ZTEMP4 1 + LSR,
( ADD_BIT $00031)
IFCS, 31 # ADC, ENDIF,
ZTEMP4 1 + LSR,
( ADD_BIT $00063)
IFCS, 63 # ADC, IFCS, INY, ENDIF,
ENDIF,
ZTEMP4 1 + LSR,
( ADD_BIT $00127)
IFCS, 27 # ADC, INY, IFCS, INY,
ENDIF, ENDIF,
ENDIF,
XSAVE STX, ZTEMP4 LDX,
( If second byte is 0, we are done)
IFNE, ' IFP2 JMP, ENDIF,
XSAVE LDX,
FR0 2 + STY, FR0 3 + STA,
42 # LDA,
FR0 STA, 0 # LDA, N STA,
' NORMALIZE JMP,

CODE IFPSUB ' IFP JSR, NEXT JMP,
DECIMAL

0 VAR FLSGN
: FLOAT DUP
  0< IF ABS -1 ELSE 1 THEN
  FLSGN !
  FR0 ! IFPSUB F>
  FLSGN @ 0< IF FNEG THEN ;

CODE X_FLT 11 ,X LDA, 5 ,X CMP,
IFCC, ' FENDT JMP, ENDIF,
IFNE, ' FENDF JMP, ENDIF,
8 ,X LDA, 2 ,X CMP,
IFCC, ' FENDT JMP, ENDIF,
IFNE, ' FENDF JMP, ENDIF,
9 ,X LDA, 3 ,X CMP,
IFCC, ' FENDT JMP, ENDIF,
IFNE, ' FENDF JMP, ENDIF,
6 ,X LDA, 0 ,X CMP,
IFCC, ' FENDT JMP, ENDIF,
IFNE, ' FENDF JMP, ENDIF,
7 ,X LDA, 1 ,X CMP,
IFCC, ' FENDT JMP, ENDIF,
' FENDF JMP,

CODE X_FGT 11 ,X LDA, 5 ,X CMP,
IFCS, IFNE, ' FENDT JMP, ENDIF,
ENDIF,
IFCC, ' FENDF JMP, ENDIF,
8 ,X LDA, 2 ,X CMP,
IFCS, IFNE, ' FENDT JMP, ENDIF,
ENDIF,
IFCC, ' FENDF JMP, ENDIF,
9 ,X LDA, 3 ,X CMP,
IFCS, IFNE, ' FENDT JMP, ENDIF,
ENDIF,
IFCC, ' FENDF JMP, ENDIF,
6 ,X LDA, 0 ,X CMP,
IFCS, IFNE, ' FENDT JMP, ENDIF,
ENDIF,
IFCC, ' FENDF JMP, ENDIF,
7 ,X LDA, 1 ,X CMP,
IFCS, IFNE, ' FENDT JMP, ENDIF,
ENDIF,
' FENDF JMP,

CODE F< SED, 10 ,X LDA, IFMI,
4 ,X LDA,
IFPL, ' FENDT JMP, ENDIF,
' X_FGT JMP,
ENDIF,
10 ,X LDA, IFPL, 4 ,X LDA,
IFMI, ' FENDF JMP, ENDIF,
ENDIF,
10 ,X LDA, 4 ,X CMP,
IFCC, ' FENDT JMP, ENDIF,
IFNE, ' FENDF JMP, ENDIF,
' X_FLT JMP,

CODE FGT SED, 10 ,X LDA, IFMI,
4 ,X LDA,
IFPL, ' FENDF JMP, ENDIF,
' X_FLT JMP,
ENDIF,
10 ,X LDA, IFPL, 4 ,X LDA,
IFMI, ' FENDT JMP, ENDIF,
ENDIF,
10 ,X LDA, 4 ,X CMP,
IFCS, IFNE, ' FENDT JMP, ENDIF,
ENDIF,
IFNE, ' FENDF JMP, ENDIF,
' X_FGT JMP,

HEX
66 CONST SQR10LB DF CONST SQR10HB
5E6 CONST FPSCR

( Move FR0 to FPSCR)
CODE FMOVSCR FR0 LDA, FPSCR STA,
FR0 1 + LDA, FPSCR 1 + STA,
FR0 2 + LDA, FPSCR 2 + STA,
FR0 3 + LDA, FPSCR 3 + STA,
FR0 4 + LDA, FPSCR 4 + STA,
FR0 5 + LDA, FPSCR 5 + STA,
RTS,

CODE LD_PLY_X PLYARG ,X LDA,
FR0 STA,
PLYARG 1 + ,X LDA, FR0 1 + STA,
PLYARG 2 + ,X LDA, FR0 2 + STA,
PLYARG 3 + ,X LDA, FR0 3 + STA,
PLYARG 4 + ,X LDA, FR0 4 + STA,
PLYARG 5 + ,X LDA, FR0 5 + STA,
XSAVE LDX, RTS,

CODE LD1_PLY_X PLYARG ,X LDA,
FR1 STA,
PLYARG 1 + ,X LDA, FR1 1 + STA,
PLYARG 2 + ,X LDA, FR1 2 + STA,
PLYARG 3 + ,X LDA, FR1 3 + STA,
PLYARG 4 + ,X LDA, FR1 4 + STA,
PLYARG 5 + ,X LDA, FR1 5 + STA,
XSAVE LDX, RTS,

CODE LD1FPSCR XSAVE STX,
6 # LDX,
( X register is restored in LD1_PLY_X)
' LD1_PLY_X JMP,

( Load FR0 from PLYARG)
CODE LDPLYARG XSAVE STX, 0 # LDX,
( X register is restored in LD_PLY_X)
' LD_PLY_X JMP,

( Compute FR0=[FR0-C]/[FR1+C] with C in [X:Y])
CODE REDRNG FLPTR STX,
FLPTR 1 + STY,
XSAVE LDX, ' FMOVPLYARG JSR,
' FLD1P JSR,
' FADD JSR, ' FMOVSCR JSR,
' LDPLYARG JSR,
' FLD1P JSR, ' FSUB JSR,
' LD1FPSCR JSR,
' FDIV JMP,

CODE RTS_SEC3 SEC, RTS,

CODE RTS_CLC CLC, RTS,

72 CONST LGCOEFLB
DF CONST LGCOEFHB

( If Accum=5 compute nat. log)
( If Accum=0 compute common log)
CODE FCLOGROUT F0 STA, FR0 LDA, 
IFMI, ' RTS_SEC3 JMP, ENDIF,
IFEQ, ' RTS_SEC3 JMP, ENDIF,
ASL.A,
80 # EOR, F1 STA, 40 # LDA,
FR0 STA,
FR0 1 + LDA, F0 # AND,
IFNE, F1 INC, ' FDIV10 JSR,
ENDIF, XSAVE STX,
SQR10LB # LDX, SQR10HB # LDY,
( X register is restored in REDRNG)
' REDRNG JSR, ' FMOVSCR JSR,
' FSQ JSR,
A # LDA, XSAVE STX,
LGCOEFLB # LDX, LGCOEFHB # LDY,
( X register is restored in PLYEVL)
' PLYEVL JSR,  ' LD1FPSCR JSR,
' FMUL JSR,
3F # LDA, FR1 STA, 50 # LDA,
FR1 1 + STA,
0 # LDA, FR1 2 + STA,
FR1 3 + STA,
FR1 4 + STA, FR1 5 + STA,
' FADD JSR,
' FMOVE JSR, F1 LDA,
IFMI, CLC, FF # EOR, 1 # ADC,
ENDIF,
FR0 STA, 0 # LDA, FR0 1 + STA,
' IFP JSR,
F1 LDA, 80 # AND, FR0 ORA,
FR0 STA,
' FADD JSR, XSAVE STX,
F0 LDX,
IFEQ, XSAVE LDX, ' RTS_CLC JMP,
ENDIF,
BEGIN, LOG10E ,X LDA, FR1 ,X STA,
DEX,
IFPL, 1 # LDA, ENDIF,
IFMI, 0 # LDA, ENDIF,
0= END, XSAVE LDX, ' FDIV JMP,

( Compute FR0=LOG_10[FR0])
CODE FCLOG 0 # LDA,
' FCLOGROUT JSR,
NEXT JMP,

: FLOG10 ( fl1-fl2) FS FCLOG F> ;

( Compute FR0=LN[FR0])
CODE FLOGROUT 5 # LDA,
' FCLOGROUT JSR,
NEXT JMP,

: FLOG ( fl1-fl2) FS FLOGROUT F> ;
DECIMAL

CODE X_FGE 11 ,X LDA, 5 ,X CMP,
IFPL, IFNE, ' FENDT JMP, ENDIF,
ENDIF,
IFCC, ' FENDF JMP, ENDIF,
8 ,X LDA, 2 ,X CMP,
IFPL, IFNE, ' FENDT JMP, ENDIF,
ENDIF,
IFCC, ' FENDF JMP, ENDIF,
9 ,X LDA, 3 ,X CMP,
IFPL, IFNE, ' FENDT JMP, ENDIF,
ENDIF,
IFCC, ' FENDF JMP, ENDIF,
6 ,X LDA, 0 ,X CMP,
IFPL, IFNE, ' FENDT JMP, ENDIF,
ENDIF,
IFCC, ' FENDF JMP, ENDIF,
7 ,X LDA, 1 ,X CMP,
IFPL, ' FENDT JMP, ENDIF,
IFCC, ' FENDF JMP, ENDIF,
' FENDT JMP,

CODE X_FLE 11 ,X LDA, 5 ,X CMP,
IFCC, ' FENDT JMP, ENDIF,
IFPL, IFNE, ' FENDF JMP, ENDIF,
ENDIF,
8 ,X LDA, 2 ,X CMP,
IFCC, ' FENDT JMP, ENDIF,
IFPL, IFNE, ' FENDF JMP, ENDIF,
ENDIF,
9 ,X LDA, 3 ,X CMP,
IFCC, ' FENDT JMP, ENDIF,
IFPL, IFNE, ' FENDF JMP, ENDIF,
ENDIF,
6 ,X LDA, 0 ,X CMP,
IFCC, ' FENDT JMP, ENDIF,
IFPL, IFNE, ' FENDF JMP, ENDIF,
ENDIF,
7 ,X LDA, 1 ,X CMP,
IFCC, ' FENDT JMP, ENDIF,
IFPL, IFNE, ' FENDF JMP, ENDIF,
ENDIF,
' FENDT JMP,

CODE F<= SED, 10 ,X LDA, IFMI,
4 ,X LDA,
IFMI, ' X_FGE JMP, ENDIF,
' FENDT JMP, ENDIF,
10 ,X LDA, IFPL, 4 ,X LDA, IFMI,
' FENDF JMP,
ENDIF, ENDIF,
10 ,X LDA, IFPL, 4 ,X CMP, IFPL,
IFNE, ' FENDF JMP,
ENDIF, ENDIF, ENDIF, ' X_FLE JMP,

CODE F>= SED, 10 ,X LDA, IFMI,
4 ,X LDA,
IFMI, ' X_FLE JMP, ENDIF,
' FENDF JMP, ENDIF,
10 ,X LDA, IFPL, 4 ,X LDA, IFMI,
' FENDT JMP,
ENDIF, ENDIF,
10 ,X LDA, 4 ,X CMP, IFPL, IFNE,
' FENDT JMP,
ENDIF, ENDIF, ' X_FGE JMP,

: F+C FR1 F! FADDSUB ;
: F-C FMOVESUB FS FSUBSUB ;
: F-CS FR1 F! FSUBSUB ;
: F*C FR1 F! FMULSUB ;
: F/C FMOVESUB FS FDIVSUB ;
: F/CS FR1 F! FDIVSUB ;
CODE FSQRC ' FSQ JSR, NEXT JMP,
: FSQR FS FSQRC F> ;

CODE SQRT_NEG SEC, RTS,
CODE SQRT_0 CLC, RTS,
CODE SQRT_OK CLC, RTS,

HEX
5EC CONST FPSCR1

( Load FR0 from FPSCR)
CODE LDFPSCR XSAVE STX,
( X register is restored in LD_PLY_X)
6 # LDX, ' LD_PLY_X JMP,

( Load FR0 from FPSCR1)
CODE LDFPSCR1 XSAVE STX,
( X register is restored in LD_PLY_X)
C # LDX, ' LD_PLY_X JMP,

( Load FR1 from FPSCR1)
CODE LD1FPSCR1 XSAVE STX,
( X register is restored in LD1_PLY_X)
C # LDX, ' LD1_PLY_X JMP,

CODE L324C ' T_ZFR0 JMP,

CODE FPHALF FR0 LDA, 7F # AND,
F # CMP,
IFCC, ' L324C JMP, ENDIF,
' FMOVE JSR, SED,
XSAVE STX, 0 # LDX, 4 # LDY, CLC,
BEGIN,
FR0 5 + LDA, FR1 5 + ADC,
FR0 5 + STA,
FR0 4 + LDA, FR1 4 + ADC,
FR0 4 + STA,
FR0 3 + LDA, FR1 3 + ADC,
FR0 3 + STA,
FR0 2 + LDA, FR1 2 + ADC,
FR0 2 + STA,
FR0 1 + LDA, FR1 1 + ADC,
FR0 1 + STA,
TXA, 0 # ADC, N STA, N LDX, DEY,
0= END,
CLD, TXA, IFEQ, XSAVE LDX,
' FDIV10 JMP, ENDIF,
FR0 4 + LDA, FR0 5 + STA,
FR0 3 + LDA, FR0 4 + STA,
FR0 2 + LDA, FR0 3 + STA,
FR0 1 + LDA, FR0 2 + STA,
FR0 1 + STX, XSAVE LDX,
' FMUL10 JMP,

CODE SQRT_END F1 LDA,
IFEQ, ' SQRT_OK JMP, ENDIF,
LSR.A, CLC, FR0 ADC, 1F # SBC,
FR0 STA, F1 LSR,
IFCC, ' SQRT_OK JMP, ENDIF,
' FMUL10 JSR,
CLC, RTS,

CODE SQRT_SKIP ' LDFPSCR1 JSR,
' SQRT_END JMP,

CODE FSQRT 0 # LDA, F1 STA,
FR0 LDA,
IFMI, ' SQRT_NEG JMP, ENDIF,
IFEQ, ' SQRT_0 JMP, ENDIF,
( 0.01 < X < 1, don't need adjustment at end)
3F # CMP, IFNE, CLC, 1 # ADC,
F1 STA, ENDIF,
6 # LDA, EF STA, 3F # LDA,
FR0 STA,
( Store original X)
' FMOVSCR JSR,
( Get starting iteration value)
' FMOVE JSR, ' FLD1 JSR,
FR0 1 + INC,
' FSUB JSR, ' LD1FPSCR JSR,
' FMUL JSR,
( Iternation loop: Z'=Z+[Z/X-Z]/2)
BEGIN,
FR0 LDA, FPSCR1 STA,
FR0 1 + LDA, FPSCR1 1 + STA,
FR0 2 + LDA, FPSCR1 2 + STA,
FR0 3 + LDA, FPSCR1 3 + STA,
FR0 4 + LDA, FPSCR1 4 + STA,
FR0 5 + LDA, FPSCR1 5 + STA,
' FMOVE JSR,
' LDFPSCR JSR, ' FDIV JSR,
' LD1FPSCR1 JSR,
' FSUB JSR, ' FPHALF JSR,
FR0 LDA,
( We are already adding 0, skip rest of iterations)
IFEQ, ' SQRT_SKIP JMP, ENDIF,
' LD1FPSCR1 JSR, ' FADD JSR,
EF DEC,
IFPL, 1 # LDA, ENDIF,
IFMI, ' SQRT_END JMP, ENDIF,
0= END,

CODE SQRTC ' FSQRT JSR, NEXT JMP,

: SQRT ( fl1-fl2) FS SQRTC F> ;

CREATE SCOEF
FP -3.551499391E-6 F,
FP 1.60442752E-4 F,
( -4.6817543551E-3)
BE C, 46 C, 81 C, 75 C, 43 C,
55 C,
FP 7.96926239E-2 F,
( -6.459640867E-1)
BF C, 64 C, 59 C, 64 C, 8 C,
67 C,
FP 1.570796324 F,

CREATE F_PI2
( used in RAD mode)
FP 1.570796324 F,
( used in DEG mode)
FP 90 F,

FB CONST DEGFLAG

CODE RTS_SEC2 SEC, RTS,

CODE SINCOS F0 STA,
( Get absolute value of FR0)
FR0 LDA, 7F # AND, FR0 STA,
( And divide by 90 deg. or PI/2)
XSAVE STX, DEGFLAG LDX,
F_PI2 ,X LDA, FR1 STA,
F_PI2 1 + ,X LDA, FR1 1 + STA,
F_PI2 2 + ,X LDA, FR1 2 + STA,
F_PI2 3 + ,X LDA, FR1 3 + STA,
F_PI2 4 + ,X LDA, FR1 4 + STA,
F_PI2 5 + ,X LDA, FR1 5 + STA,
XSAVE LDX, ' FDIV JSR,
IFCS, ' RTS_SEC2 JMP, ENDIF,
( Extract integer/fractional parts)
FR0 LDA, 7F # AND, SEC, 40 # SBC,
IFPL, 4 # CMP, ( >= 1.0)
( More than 100000000, error)
IFPL, ' RTS_SEC2 JMP, ENDIF,
XSAVE STX, N STA, N LDX,
( Get lower two digits)
FR0 1 + ,X LDA,
( Calculate [10*A+B] MOD 4 == [[A MOD 2]*2+B] MOD 4)
F1 STA, 10 # AND,
IFNE, 2 # LDA, ENDIF,
CLC, F1 ADC,
( We now have the quadrant)
3 # AND,
( Add starting quadrant from the start)
F0 ADC, F0 STA, F1 STX, 0 # LDA,
BEGIN, ( Set integer part to 0)
FR0 1 + ,X STA, DEX,
IFEQ, 1 # LDY, ENDIF,
IFMI, 0 # LDY, ENDIF,
0= END,
( And normalize FP number)
XSAVE LDX, N STA, ' NORMALIZE JSR,
ENDIF,
( Check odd quadrants, and compute FR0=1-FR0)
F0 LSR,
IFCS, ' FMOVE JSR, ' FLD1 JSR,
' FSUB JSR, ENDIF,
( Store FR0 into FPSCR)
' FMOVSCR JSR,
( And get FR0^2)
' FSQ JSR,
IFCS, ' RTS_SEC2 JMP, ENDIF,
6 # LDA, XSAVE STX,
SCOEF LB # LDX, SCOEF HB # LDY,
( Evaluate polynomial in X^2)
( X register is restored in PLYEVL)
' PLYEVL JSR, ' LD1FPSCR JSR,
( Multiply by original X)
' FMUL JSR,
( Check quadrant to negate result)
F0 LSR,
IFCS, CLC, FR0 LDA,
IFNE, 80 # EOR, FR0 STA, ENDIF,
ENDIF, RTS,

CODE FCOSC ( Positive/Negative COS)
1 # LDA, ' SINCOS JSR, NEXT JMP,

CODE FSINC ( Positive SIN)
4 # LDA, FR0 BIT,
IFPL, ' SINCOS JSR, NEXT JMP,
ENDIF,
( Negative SIN)
2 # LDA, ' SINCOS JSR, NEXT JMP,

: SIN ( fl1-fl2) FS FSINC F> ;
: COS ( fl1-fl2) FS FCOSC F> ;

CODE DEG 6 # LDA, DEGFLAG STA,
NEXT JMP,

CODE RAD 0 # LDA, DEGFLAG STA,
NEXT JMP,

CREATE F_1DEG ( PI/180)
FP 0.0174532925 F,

DFAE CONST ATNCOEF
DFEA CONST FP9S
DFF0 CONST FP_PI4

CODE L31C0 RTS,

CODE L31AF DEGFLAG LDA,
IFEQ, ' L31C0 JMP, ENDIF,
XSAVE STX,
( Original code loads 5)
6 # LDX, BEGIN,
DEX, F_1DEG ,X LDA, FR1 ,X STA,
TXA, 0= END,
XSAVE LDX, ' FDIV JSR, RTS,

CODE FATN 0 # LDA, F0 STA, F1 STA,
FR0 LDA, 7F # AND, 40 # CMP,
IFPL,
FR0 LDA, 80 # AND, F0 STA,
F1 INC,
7F # LDA, FR0 AND, FR0 STA,
XSAVE STX, FP9S LB # LDX,
FP9S HB # LDY,
( X register is restored in REDRNG)
' REDRNG JSR,
ENDIF,
' FMOVSCR JSR, ' FSQ JSR,
IFCS, ' L31C0 JMP, ENDIF,
B # LDA,
XSAVE STX, ATNCOEF LB # LDX,
ATNCOEF HB # LDY,
( X register is restored in PLYEVL)
' PLYEVL JSR,
IFCS, ' L31C0 JMP, ENDIF,
' LD1FPSCR JSR,
' FMUL JSR,
IFCS, ' L31C0 JMP, ENDIF,
F1 LDA, IFEQ, ' L31AF JMP, ENDIF,
XSAVE STX,
( Original code loads 5)
6 # LDX, BEGIN,
DEX, FP_PI4 ,X LDA, FR1 ,X STA,
TXA, 0= END,
XSAVE LDX, ' FADD JSR,
F0 LDA, FR0 ORA, FR0 STA,
' L31AF JMP,

CODE ATNC ' FATN JSR, NEXT JMP,

: ATN ( fl1-fl2) FS ATNC F> ;

: TAN ( fl1-fl2) FDUP SIN FSWAP
  COS F/ ;
DECIMAL

( === Some useful words not part of TB port ===)

: FI? F@ INT . ;
: FI@ ( -n) F@ INT ;

: FPOW ( fl1 fl2-fl3) FSWAP FLOG10
  F* FEXP10 ;

: FIPOW ( fl1 n-fl2) >R FDUP
  FDUP R> 1 DO F* FOVER
  LOOP FDROP FSWAP
  FDROP ;

: FVAR FVARIABLE ;
: FCONST FCONSTANT ;

: FARRAY <BUILDS 6 * ALLOT DOES>
  SWAP 6 * + ;
